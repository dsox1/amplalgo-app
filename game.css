// Core game state and rules for Backyard Black Jack (Daytime, Chaos Mode)

const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

const UI = {
  deckCard: document.getElementById('deck-card'),
  discardCard: document.getElementById('discard-card'),
  deckCount: document.getElementById('deck-count'),
  aiHand: document.getElementById('ai-hand'),
  playerHand: document.getElementById('player-hand'),
  aiCount: document.getElementById('ai-count'),
  playerCount: document.getElementById('player-count'),
  status: document.getElementById('status'),
  btnPlaySelected: document.getElementById('btn-play-selected'),
  btnClear: document.getElementById('btn-clear'),
  btnDraw: document.getElementById('btn-draw'),
  btnLastCard: document.getElementById('btn-last-card'),
  btnPlay: document.getElementById('btn-play'),
  btnRules: document.getElementById('btn-rules'),
  btnThemes: document.getElementById('btn-themes'),
  btnStats: document.getElementById('btn-stats'),
  rulesDialog: document.getElementById('rules-dialog'),
  themesDialog: document.getElementById('themes-dialog'),
  statsDialog: document.getElementById('stats-dialog'),
  closeRules: document.getElementById('close-rules'),
  closeThemes: document.getElementById('close-themes'),
  closeStats: document.getElementById('close-stats'),
};

const settings = {
  chaosMode: true,                 // default on
  jokerEnabled: true,             // Joker is wild
  jokerCanMimicBlackJack: true,   // toggle to exclude Black Jack mimicry if desired
  startingHand: 7,
  doubleDeck: false,              // future option
};

const stats = {
  sessionGames: 0,
  sessionWins: 0,
  sessionLosses: 0,
};

const game = {
  deck: [],
  discard: [],
  player: [],
  ai: [],
  direction: 1,           // 1 = player -> ai ; -1 = ai -> player (for future multi-player)
  current: 'player',
  mustPickup: 0,          // penalty cards to pick up
  penaltyType: '',        // '2' or 'Black Jack'
  lastCardDeclared: false,
  gameOver: false,
  aiThinking: false,
  awaitingLastCardWindow: false,  // prevents instant penalty before user can press button
};

function createDeck() {
  const d = [];
  const copies = settings.doubleDeck ? 2 : 1;
  for (let c = 0; c < copies; c++) {
    for (const s of suits) {
      for (const r of ranks) {
        d.push({ rank: r, suit: s, joker: false });
      }
    }
    // Add Jokers (2 per deck typical, optional here)
    d.push({ rank: 'JOKER', suit: '‚òÖ', joker: true });
    d.push({ rank: 'JOKER', suit: '‚òÜ', joker: true });
  }
  // Shuffle
  for (let i = d.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}

function startGame() {
  Object.assign(game, {
    deck: createDeck(),
    discard: [],
    player: [],
    ai: [],
    direction: 1,
    current: 'player',
    mustPickup: 0,
    penaltyType: '',
    lastCardDeclared: false,
    gameOver: false,
    aiThinking: false,
    awaitingLastCardWindow: false,
  });

  dealHands();
  // Flip first discard (avoid immediate power card if possible)
  let top;
  do {
    top = game.deck.pop();
  } while (top && (top.rank === 'JOKER' || top.rank === 'A' || top.rank === 'J' || top.rank === '2' || top.rank === '8' || top.rank === 'K'));
  game.discard.push(top || game.deck.pop());

  renderAll();
  setStatus('Your turn! Match suit or rank, or play a power card.');
}

function dealHands() {
  for (let i = 0; i < settings.startingHand; i++) {
    game.player.push(game.deck.pop());
    game.ai.push(game.deck.pop());
  }
}

function renderAll() {
  renderCenterStacks();
  renderHands();
  renderCounts();
  updateControls();
}

function renderCenterStacks() {
  UI.deckCount.textContent = game.deck.length;
  UI.deckCard.textContent = 'üÇ†';
  const top = game.discard[game.discard.length - 1];
  UI.discardCard.innerHTML = cardHTML(top);
}

function renderCounts() {
  UI.playerCount.textContent = game.player.length;
  UI.aiCount.textContent = game.ai.length;
}

function renderHands() {
  // Player hand
  UI.playerHand.innerHTML = '';
  game.player.forEach((card, idx) => {
    const el = document.createElement('div');
    el.className = 'card selectable';
    el.innerHTML = cardHTML(card);
    el.addEventListener('click', () => toggleSelect(idx));
    UI.playerHand.appendChild(el);
  });

  // AI hand (backs only)
  UI.aiHand.innerHTML = '';
  game.ai.forEach(() => {
    const el = document.createElement('div');
    el.className = 'card back';
    el.textContent = 'üÇ†';
    UI.aiHand.appendChild(el);
  });
}

let selected = new Set();

function toggleSelect(idx) {
  if (game.current !== 'player' || game.gameOver) return;
  const el = UI.playerHand.children[idx];
  if (selected.has(idx)) {
    selected.delete(idx);
    el.classList.remove('selected');
  } else {
    selected.add(idx);
    el.classList.add('selected');
  }
  updateControls();
}

function clearSelection() {
  selected.clear();
  [...UI.playerHand.children].forEach(el => el.classList.remove('selected'));
  updateControls();
}

function updateControls() {
  const canPlay = canPlaySelected();
  UI.btnPlaySelected.disabled = !canPlay;

  // Show Last Card button when player has 1 card and not yet declared
  const showLastCard = game.current === 'player' &&
                       game.player.length === 1 &&
                       !game.lastCardDeclared;
  UI.btnLastCard.style.display = showLastCard ? 'inline-block' : 'none';
}

function canPlaySelected() {
  if (selected.size === 0) return false;
  // Penalty state: must play valid penalty stack/cancel card
  if (game.mustPickup > 0) {
    if (selected.size !== 1) return false;
    const card = game.player[[...selected][0]];
    return canStackPenalty(card);
  }
  // Normal state: selected can be 1 card or a run (same rank)
  const chosen = [...selected].map(i => game.player[i]);
  if (chosen.length === 1) {
    return isPlayableSingle(chosen[0]);
  }
  // Run: same rank, any suits (power card effects only apply to last played single)
  const r = chosen[0].rank;
  if (!chosen.every(c => c.rank === r)) return false;
  // First card of run must be playable against top discard
  return isPlayableSingle(chosen[0]);
}

function isPlayableSingle(card) {
  const top = game.discard[game.discard.length - 1];

  // Joker logic
  if (settings.jokerEnabled && card.joker) {
    return true; // wild
  }
  // Ace can be played anytime
  if (card.rank === 'A') return true;

  // Match suit or rank
  if (card.suit === top.suit || card.rank === top.rank) return true;

  // Red Jack cancel if penalty active
  if (game.mustPickup > 0 && game.penaltyType === 'Black Jack') {
    if (card.rank === 'J' && (card.suit === '‚ô•' || card.suit === '‚ô¶')) return true;
  }

  return false;
}

function canStackPenalty(card) {
  // Joker: can mimic a valid penalty stack or cancel
  if (settings.jokerEnabled && card.joker) return true;

  if (game.penaltyType === '2' && card.rank === '2') return true;
  if (game.penaltyType === 'Black Jack') {
    // Stack more Black Jacks (black suits) or cancel with Red Jack
    if (card.rank === 'J' && (card.suit === '‚ô†' || card.suit === '‚ô£')) return true;
    if (card.rank === 'J' && (card.suit === '‚ô•' || card.suit === '‚ô¶')) return true;
  }
  return false;
}

function playSelected() {
  if (!canPlaySelected() || game.current !== 'player' || game.gameOver) return;

  const indices = [...selected].sort((a, b) => b - a);
  const cards = indices.map(i => game.player[i]);

  // Penalty response
  if (game.mustPickup > 0) {
    const card = cards[0];
    resolvePenaltyPlay(card, 'player');
    // remove from hand
    indices.forEach(i => game.player.splice(i, 1));
    game.discard.push(card);
    clearSelection();
    renderAll();
    if (!game.gameOver) setTimeout(aiTurn, 650);
    return;
  }

  // Normal play: allow runs (same rank). Apply effects for each card in sequence,
  // but core rule: power effects triggered by the last single card played (your house rule can vary).
  let lastPlayed = null;
  indices.forEach(i => {
    const c = game.player[i];
    lastPlayed = c;
  });
  // remove in order
  indices.forEach(i => game.player.splice(i, 1));
  // push cards in their display order
  cards.forEach(c => game.discard.push(c));

  applyCardEffects(lastPlayed, 'player');

  clearSelection();
  renderAll();

  // Last Card declaration window (give a fair chance)
  if (game.player.length === 1 && !game.lastCardDeclared) {
    game.awaitingLastCardWindow = true;
    setStatus('Declare ‚ÄúLast Card!‚Äù now.');
    setTimeout(() => {
      game.awaitingLastCardWindow = false;
      // If not declared by now, apply penalty
      if (!game.lastCardDeclared && game.player.length === 1) {
        setStatus('Penalty: you forgot ‚ÄúLast Card!‚Äù (+2 cards)');
        pickupCards('player', 2);
        renderAll();
      }
      if (!game.gameOver) setTimeout(aiTurn, 650);
    }, 1800);
    return;
  }

  if (game.player.length === 0) {
    playerWins();
    return;
  }

  if (!game.gameOver) setTimeout(aiTurn, 650);
}

function resolvePenaltyPlay(card, actor) {
  // Joker mimicking logic
  if (settings.jokerEnabled && card.joker) {
    // If penalty is Black Jack and mimic is excluded, treat Joker as Red Jack (cancel)
    if (game.penaltyType === 'Black Jack' && !settings.jokerCanMimicBlackJack) {
      game.mustPickup = 0; game.penaltyType = '';
      setStatus(`${actorText(actor)} played Joker (cancel Black Jack).`);
      return;
    }
    // else mimic the current penalty card to stack further
    if (game.penaltyType === '2') {
      game.mustPickup += 2;
      setStatus(`${actorText(actor)} played Joker (stack +2). Total ${game.mustPickup}.`);
      return;
    }
    if (game.penaltyType === 'Black Jack') {
      game.mustPickup += 6;
      setStatus(`${actorText(actor)} played Joker (stack +6). Total ${game.mustPickup}.`);
      return;
    }
  }

  // Real cards
  if (game.penaltyType === '2' && card.rank === '2') {
    game.mustPickup += 2;
    setStatus(`${actorText(actor)} stacked 2. Total pickup ${game.mustPickup}.`);
    return;
  }
  if (game.penaltyType === 'Black Jack') {
    if (card.rank === 'J' && (card.suit === '‚ô†' || card.suit === '‚ô£')) {
      game.mustPickup += 6;
      setStatus(`${actorText(actor)} stacked Black Jack. Total pickup ${game.mustPickup}.`);
      return;
    }
    if (card.rank === 'J' && (card.suit === '‚ô•' || card.suit === '‚ô¶')) {
      game.mustPickup = 0; game.penaltyType = '';
      setStatus(`${actorText(actor)} played Red Jack ‚Äî penalty cancelled.`);
      return;
    }
  }
}

function applyCardEffects(card, actor) {
  if (!card) return;
  const top = card;

  // Joker: wild, no direct penalty unless mimicking through penalty flow
  if (settings.jokerEnabled && top.joker) {
    setStatus(`${actorText(actor)} played Joker (wild).`);
    return;
  }

  // Ace: changes suit to suit of Ace (visual rule; gameplay: next must match new suit)
  if (top.rank === 'A') {
    // We change the suit context by pushing Ace; matching is against discard top anyway.
    setStatus(`${actorText(actor)} played Ace ‚Äî suit is now ${top.suit}.`);
    return;
  }

  // King: reverse direction (matters in >2 players; here we simulate as extra player turn for human)
  if (top.rank === 'K') {
    game.direction *= -1;
    setStatus(`${actorText(actor)} played King ‚Äî reverse direction.`);
    return;
  }

  // 8: skip next player
  if (top.rank === '8') {
    setStatus(`${actorText(actor)} played 8 ‚Äî next turn is skipped.`);
    skipNextTurn();
    return;
  }

  // 2: start/override penalty
  if (top.rank === '2') {
    game.mustPickup = 2;
    game.penaltyType = '2';
    setStatus(`${actorText(actor)} played 2 ‚Äî next must pick up 2 or stack.`);
    return;
  }

  // Black Jack: ‚ô† or ‚ô£ = +6; Red Jack cancels only in penalty response
  if (top.rank === 'J' && (top.suit === '‚ô†' || top.suit === '‚ô£')) {
    game.mustPickup = 6;
    game.penaltyType = 'Black Jack';
    setStatus(`${actorText(actor)} played Black Jack ‚Äî next must pick up 6 or stack.`);
    return;
  }

  // Red Jack as a normal play (no penalty effect here)
  if (top.rank === 'J' && (top.suit === '‚ô•' || top.suit === '‚ô¶')) {
    setStatus(`${actorText(actor)} played Red Jack.`);
    return;
  }

  // Normal
  setStatus(`${actorText(actor)} played ${top.rank}${top.suit}.`);
}

function actorText(actor) {
  return actor === 'player' ? 'You' : 'AI';
}

function setStatus(text) {
  UI.status.textContent = text;
}

UI.btnPlay.addEventListener('click', startGame);
UI.btnClear.addEventListener('click', clearSelection);
UI.btnPlaySelected.addEventListener('click', playSelected);
UI.btnDraw.addEventListener('click', drawCard);
UI.btnLastCard.addEventListener('click', declareLastCard);
UI.deckCard.addEventListener('click', drawCard);

// Dialogs
UI.btnRules.addEventListener('click', () => UI.rulesDialog.showModal());
UI.closeRules.addEventListener('click', () => UI.rulesDialog.close());
UI.btnThemes.addEventListener('click', () => UI.themesDialog.showModal());
UI.closeThemes.addEventListener('click', () => UI.themesDialog.close());
UI.btnStats.addEventListener('click', () => {
  document.getElementById('session-games').textContent = stats.sessionGames;
  document.getElementById('session-wins').textContent = stats.sessionWins;
  document.getElementById('session-losses').textContent = stats.sessionLosses;
  document.getElementById('session-winrate').textContent =
    stats.sessionGames > 0 ? Math.round((stats.sessionWins / stats.sessionGames) * 100) + '%' : '0%';
  UI.statsDialog.showModal();
});
UI.closeStats.addEventListener('click', () => UI.statsDialog.close());

// Gameplay actions
function drawCard() {
  if (game.current !== 'player' || game.gameOver) return;

  // Penalty pickup
  if (game.mustPickup > 0) {
    pickupCards('player', game.mustPickup);
    game.mustPickup = 0;
    game.penaltyType = '';
    setStatus(`You picked up penalty cards.`);
    renderAll();
    setTimeout(aiTurn, 650);
    return;
  }

  // Normal draw
  if (game.deck.length > 0) {
    game.player.push(game.deck.pop());
    setStatus('You drew a card.');
    renderAll();
  } else {
    setStatus('Deck empty.');
  }
}

function pickupCards(who, count) {
  for (let i = 0; i < count; i++) {
    const drawFrom = game.deck.length ? game.deck : recycleDiscardIntoDeck();
    if (!drawFrom.length) break;
    const card = drawFrom.pop();
    if (who === 'player') game.player.push(card);
    else game.ai.push(card);
  }
}

function recycleDiscardIntoDeck() {
  // Leave top card, recycle the rest
  const keep = game.discard.pop();
  const pool = game.discard;
  // shuffle
  for (let i = pool.length - 1; i > 0; i++) {
    const j = Math.floor(Math.random() * (i + 1));
    [pool[i], pool[j]] = [pool[j], pool[i]];
  }
  game.discard = [keep];
  game.deck = pool;
  return game.deck;
}

function declareLastCard() {
  if (game.player.length === 1) {
    game.lastCardDeclared = true;
    setStatus('You declared ‚ÄúLast Card!‚Äù.');
    UI.btnLastCard.style.display = 'none';
  }
}

function skipNextTurn() {
  // In 2-player, if player played 8, skip AI; if AI played, skip player
  if (game.current === 'player') {
    // immediately give turn back to player after AI turn would have happened
    setTimeout(() => {
      setStatus('AI skipped. Your turn again.');
      game.current = 'player';
      renderAll();
    }, 500);
  } else {
    setStatus('Your turn was skipped.');
  }
}

function aiTurn() {
  if (game.gameOver) return;
  game.current = 'ai';
  game.aiThinking = true;
  setStatus('AI is thinking...');
  renderAll();

  setTimeout(() => {
    // Penalty response first
    if (game.mustPickup > 0) {
      // Try to stack/cancel
      const move = aiFindPenaltyMove();
      if (move) {
        const idx = move.idx;
        const card = game.ai.splice(idx, 1)[0];
        resolvePenaltyPlay(card, 'ai');
        game.discard.push(card);
        renderAll();
      } else {
        // pick up penalty
        pickupCards('ai', game.mustPickup);
        setStatus(`AI picked up ${game.mustPickup} penalty cards.`);
        game.mustPickup = 0;
        game.penaltyType = '';
        renderAll();
      }
      // after penalty stage, back to player
      game.current = 'player';
      game.aiThinking = false;
      endChecks();
      return;
    }

    // Normal play: find playable single or run (simple: play first valid single)
    const top = game.discard[game.discard.length - 1];
    const choice = aiFindPlayable(top);
    if (choice !== null) {
      const card = game.ai.splice(choice, 1)[0];
      game.discard.push(card);
      applyCardEffects(card, 'ai');
      renderAll();

      if (game.ai.length === 1) {
        // AI always "declares" internally; no penalty
      }
      if (game.ai.length === 0) {
        aiWins();
        return;
      }
    } else {
      // Draw
      if (game.deck.length > 0) {
        game.ai.push(game.deck.pop());
        setStatus('AI drew a card.');
        renderAll();
      } else {
        setStatus('AI passes (deck empty).');
      }
    }

    // End of AI turn -> back to player
    game.current = 'player';
    game.aiThinking = false;
    endChecks();
  }, 600);
}

function endChecks() {
  // If top is 8 and was just played by AI, skip you
  const top = game.discard[game.discard.length - 1];
  if (top && top.rank === '8' && game.current === 'player') {
    setStatus('Your turn was skipped by 8.');
    // immediate AI turn again
    setTimeout(aiTurn, 600);
    return;
  }
  updateControls();
}

function aiFindPenaltyMove() {
  // Try Red Jack to cancel if Black Jack penalty; else try stack
  for (let i = 0; i < game.ai.length; i++) {
    const c = game.ai[i];
    if (canStackPenalty(c)) return { idx: i };
    // Joker can stack/cancel as allowed
    if (settings.jokerEnabled && c.joker) return { idx: i };
  }
  return null;
}

function aiFindPlayable(top) {
  // Try Ace first (often strategic)
  for (let i = 0; i < game.ai.length; i++) {
    const c = game.ai[i];
    if (c.rank === 'A' || (settings.jokerEnabled && c.joker)) return i;
  }
  // Try match suit
  for (let i = 0; i < game.ai.length; i++) {
    const c = game.ai[i];
    if (!c.joker && c.suit === top.suit) return i;
  }
  // Try match rank
  for (let i = 0; i < game.ai.length; i++) {
    const c = game.ai[i];
    if (!c.joker && c.rank === top.rank) return i;
  }
  // Try power cards if allowed by match (Black Jack if matching rank/suit)
  for (let i = 0; i < game.ai.length; i++) {
    const c = game.ai[i];
    if (!c.joker && c.rank === 'J' && (c.suit === '‚ô†' || c.suit === '‚ô£')) {
      // playable only if it matches suit/rank or Ace/Joker rule; reuse isPlayableSingle
      if (isPlayableSingle(c)) return i;
    }
  }
  return null;
}

function playerWins() {
  setStatus('You win! üéâ');
  game.gameOver = true;
  stats.sessionGames++;
  stats.sessionWins++;
}

function aiWins() {
  setStatus('AI wins! ‚ö°');
  game.gameOver = true;
  stats.sessionGames++;
  stats.sessionLosses++;
}

// Card rendering
function cardHTML(card) {
  if (!card) return '--';
  if (card.joker) {
    return `
      <div class="card-face">
        <div class="card-corners"><span>JOKER</span><span>‚òÖ</span></div>
        <div class="card-icon"><span class="black">?</span></div>
        <div class="card-corners"><span>‚òÜ</span><span>JOKER</span></div>
      </div>
    `;
  }
  const isRed = card.suit === '‚ô•' || card.suit === '‚ô¶';
  const suitClass = isRed ? 'red' : 'black';
  // Face symbols: King=‚ôõ, Queen=‚ôï, Jack=üõ° (shield emoji as placeholder), others show suit
  let centerIcon = card.suit;
  if (card.rank === 'K') centerIcon = '‚ôõ';
  if (card.rank === 'Q') centerIcon = '‚ôï';
  if (card.rank === 'J') centerIcon = 'üõ°';
  return `
    <div class="card-face">
      <div class="card-corners ${suitClass}">
        <span>${card.rank}</span><span>${card.suit}</span>
      </div>
      <div class="card-icon ${suitClass}">
        <span>${centerIcon}</span>
      </div>
      <div class="card-corners ${suitClass}">
        <span>${card.suit}</span><span>${card.rank}</span>
      </div>
    </div>
  `;
}

// Initialize buttons on load
document.addEventListener('DOMContentLoaded', () => {
  setStatus('Welcome! Tap Play to start.');
});
