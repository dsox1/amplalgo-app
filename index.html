<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imperial Black - Backyard Card Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Navigation Bar */
        .nav-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }

        .nav-title {
            font-size: 18px;
            font-weight: bold;
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
        }

        .nav-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }

        .nav-btn:hover {
            background: #45a049;
        }

        .nav-btn.active {
            background: #FF6B6B;
        }

        /* Screen Container */
        .screen {
            display: none;
            padding-top: 60px;
            min-height: 100vh;
        }

        .screen.active {
            display: block;
        }

        /* Menu Screen */
        .menu-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }

        .title {
            font-size: 4rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 2rem;
            text-align: center;
        }

        .menu-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 20px 40px;
            margin: 10px;
            border-radius: 15px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }

        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        /* Game Screen */
        .game-container {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .game-message {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .ai-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
        }

        .card-back {
            width: 60px;
            height: 84px;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            border: 2px solid #FFD700;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #FFD700;
            font-size: 24px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .play-area {
            background: rgba(139, 69, 19, 0.8);
            border-radius: 50px;
            padding: 30px;
            margin: 30px auto;
            width: fit-content;
            display: flex;
            gap: 30px;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .deck, .discard {
            text-align: center;
        }

        .deck-card, .discard-card {
            width: 80px;
            height: 112px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
        }

        .deck-card {
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            color: #FFD700;
        }

        .discard-card {
            background: white;
            border: 2px solid #333;
        }

        .player-section {
            text-align: center;
            margin-top: 30px;
        }

        .player-hand {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 20px 0;
            flex-wrap: wrap;
            max-width: 100%;
            overflow-x: auto;
            padding: 10px;
        }

        .card {
            width: 70px;
            height: 98px;
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: bold;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .card.selected {
            border-color: #FFD700;
            background: #FFFACD;
            transform: translateY(-10px);
            box-shadow: 0 6px 12px rgba(255, 215, 0, 0.5);
        }

        .card.playable {
            border-color: #4CAF50;
            background: #F0FFF0;
        }

        .card.unplayable {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .red { color: red; }
        .black { color: black; }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.3s;
            min-width: 120px;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }

        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .control-btn.danger {
            background: linear-gradient(45deg, #FF6B6B, #FF5252);
        }

        .control-btn.warning {
            background: linear-gradient(45deg, #FFA726, #FF9800);
        }

        .control-btn.last-card {
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
            font-size: 16px;
            padding: 15px 30px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .penalty-counter {
            background: #FF6B6B;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            margin: 10px 0;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Win Message */
        .win-message {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #333;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0,0,0,0.5);
            z-index: 999;
            animation: winPop 0.5s ease-out;
            max-width: 400px;
        }

        @keyframes winPop {
            0% { transform: translateX(-50%) scale(0); }
            100% { transform: translateX(-50%) scale(1); }
        }

        .win-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #333;
        }

        /* Game Log Screen */
        .log-screen {
            background: #000;
            color: #00FF00;
            font-family: 'Courier New', monospace;
            padding: 20px;
            min-height: 100vh;
        }

        .log-container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .log-content {
            flex: 1;
            background: rgba(0, 50, 0, 0.8);
            border: 2px solid #00FF00;
            border-radius: 10px;
            padding: 20px;
            height: 80vh;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 10px;
            padding: 5px;
            border-left: 3px solid #00FF00;
            padding-left: 10px;
        }

        .log-timestamp {
            color: #888;
            font-size: 12px;
        }

        .ad-space {
            width: 200px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed #666;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        /* Score Screen */
        .score-screen {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            min-height: 100vh;
        }

        .score-container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .score-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
        }

        .score-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .score-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .score-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .score-value {
            font-weight: bold;
            color: #FFD700;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .title {
                font-size: 2.5rem;
            }
            
            .card {
                width: 50px;
                height: 70px;
                font-size: 12px;
            }
            
            .deck-card, .discard-card {
                width: 60px;
                height: 84px;
                font-size: 18px;
            }
            
            .log-container, .score-container {
                flex-direction: column;
            }
            
            .ad-space {
                width: 100%;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <div class="nav-bar">
        <div class="nav-title">Imperial Black</div>
        <div class="nav-buttons">
            <button class="nav-btn" onclick="showScreen('menu')">Menu</button>
            <button class="nav-btn" onclick="showScreen('game')">Game</button>
            <button class="nav-btn" onclick="showScreen('log')">Log</button>
            <button class="nav-btn" onclick="showScreen('scores')">Scores</button>
        </div>
    </div>

    <!-- Menu Screen -->
    <div id="menu" class="screen active menu-screen">
        <h1 class="title">Backyard<br>Black Jack</h1>
        <button class="menu-btn" onclick="startNewGame()">💎 PLAY GAME</button>
        <button class="menu-btn" onclick="showScreen('log')">📊 GAME LOG</button>
        <button class="menu-btn" onclick="showScreen('scores')">🏆 SCORES</button>
        <button class="menu-btn" onclick="showRules()">📖 HOW TO PLAY</button>
    </div>

    <!-- Game Screen -->
    <div id="game" class="screen">
        <div class="game-container">
            <div class="game-message" id="gameMessage">Welcome to Imperial Black!</div>
            
            <div class="ai-section">
                <div>🤖 AI Player - <span id="aiCardCount">7</span> cards</div>
                <div class="ai-cards" id="aiCards"></div>
            </div>

            <div class="play-area">
                <div class="deck">
                    <div class="deck-card">🂠</div>
                    <div>Deck (<span id="deckCount">37</span>)</div>
                </div>
                <div class="discard">
                    <div class="discard-card" id="discardCard">🂡</div>
                    <div>Discard</div>
                </div>
            </div>

            <div id="penaltyCounter" class="penalty-counter" style="display: none;"></div>

            <div class="player-section">
                <div>💎 Your Hand - <span id="playerCardCount">7</span> cards</div>
                <div class="player-hand" id="playerHand"></div>
            </div>

            <div class="game-controls">
                <button class="control-btn last-card" id="lastCardBtn" onclick="declareLastCard()" style="display: none;">
                    🗣️ LAST CARD!
                </button>
                <button class="control-btn" id="playBtn" onclick="playSelectedCards()" style="display: none;">
                    🎯 Play Selected (<span id="selectedCount">0</span>)
                </button>
                <button class="control-btn warning" id="clearBtn" onclick="clearSelection()" style="display: none;">
                    ❌ Clear Selection
                </button>
                <button class="control-btn" id="drawBtn" onclick="drawCard()">
                    🃏 Draw Card
                </button>
                <button class="control-btn danger" id="pickupBtn" onclick="pickupPenalty()" style="display: none;">
                    ⚠️ Pick Up <span id="pickupCount">0</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Game Log Screen -->
    <div id="log" class="screen log-screen">
        <div class="log-container">
            <div class="log-content">
                <h2 style="color: #00FF00; text-align: center; margin-bottom: 20px;">GAME ACTION LOG</h2>
                <div id="logEntries">
                    <div class="log-entry">
                        <div class="log-timestamp">[System]</div>
                        <div>Game log initialized. Ready to track all actions.</div>
                    </div>
                </div>
            </div>
            <div class="ad-space">
                <h3>Advertisement Space</h3>
                <p>Rotating ads will appear here</p>
                <div style="margin-top: 20px; padding: 20px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                    <strong>Sample Ad</strong><br>
                    Play More Games!<br>
                    <small>Visit our game portal</small>
                </div>
            </div>
        </div>
    </div>

    <!-- Score Screen -->
    <div id="scores" class="screen score-screen">
        <div class="score-container">
            <div class="score-content">
                <h2 class="score-title">🏆 GAME STATISTICS</h2>
                
                <div class="score-section">
                    <h3 style="color: #FFD700; margin-bottom: 15px;">Current Session</h3>
                    <div class="score-stat">
                        <span>Games Played:</span>
                        <span class="score-value" id="sessionGames">0</span>
                    </div>
                    <div class="score-stat">
                        <span>Wins:</span>
                        <span class="score-value" id="sessionWins">0</span>
                    </div>
                    <div class="score-stat">
                        <span>Losses:</span>
                        <span class="score-value" id="sessionLosses">0</span>
                    </div>
                    <div class="score-stat">
                        <span>Win Rate:</span>
                        <span class="score-value" id="sessionWinRate">0%</span>
                    </div>
                </div>

                <div class="score-section">
                    <h3 style="color: #FFD700; margin-bottom: 15px;">All Time</h3>
                    <div class="score-stat">
                        <span>Total Games:</span>
                        <span class="score-value" id="totalGames">0</span>
                    </div>
                    <div class="score-stat">
                        <span>Total Wins:</span>
                        <span class="score-value" id="totalWins">0</span>
                    </div>
                    <div class="score-stat">
                        <span>Total Losses:</span>
                        <span class="score-value" id="totalLosses">0</span>
                    </div>
                    <div class="score-stat">
                        <span>Overall Win Rate:</span>
                        <span class="score-value" id="totalWinRate">0%</span>
                    </div>
                </div>

                <div class="score-section">
                    <h3 style="color: #FFD700; margin-bottom: 15px;">Game Records</h3>
                    <div class="score-stat">
                        <span>Fastest Win:</span>
                        <span class="score-value" id="fastestWin">--</span>
                    </div>
                    <div class="score-stat">
                        <span>Longest Game:</span>
                        <span class="score-value" id="longestGame">--</span>
                    </div>
                    <div class="score-stat">
                        <span>Best Streak:</span>
                        <span class="score-value" id="bestStreak">0</span>
                    </div>
                </div>

                <div style="text-align: center; margin-top: 30px;">
                    <button class="control-btn danger" onclick="resetStats()">Reset All Statistics</button>
                </div>
            </div>
            <div class="ad-space">
                <h3>Premium Features</h3>
                <p>Upgrade for advanced statistics and ad-free experience</p>
                <div style="margin-top: 20px; padding: 20px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                    <strong>Upgrade Now!</strong><br>
                    • Detailed analytics<br>
                    • No advertisements<br>
                    • Custom themes<br>
                    <button class="control-btn" style="margin-top: 10px;">Upgrade</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            deck: [],
            playerHand: [],
            aiHand: [],
            discardPile: [],
            selectedCards: [],
            currentPlayer: 'player',
            direction: 1,
            penaltyCount: 0,
            penaltyType: '',
            gameStartTime: null,
            lastCardDeclared: false,
            gameLog: [],
            sessionStats: { games: 0, wins: 0, losses: 0 },
            totalStats: { games: 0, wins: 0, losses: 0, fastestWin: null, longestGame: null, bestStreak: 0, currentStreak: 0 }
        };

        // Card definitions
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const suitColors = { '♠': 'black', '♣': 'black', '♥': 'red', '♦': 'red' };

        // Initialize game
        function initializeGame() {
            loadStats();
            createDeck();
            dealCards();
            updateDisplay();
            logAction('Game started', 'system');
            gameState.gameStartTime = Date.now();
        }

        function createDeck() {
            gameState.deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    gameState.deck.push({ rank, suit });
                }
            }
            shuffleDeck();
        }

        function shuffleDeck() {
            for (let i = gameState.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
        }

        function dealCards() {
            gameState.playerHand = [];
            gameState.aiHand = [];
            gameState.discardPile = [];
            gameState.selectedCards = [];
            gameState.penaltyCount = 0;
            gameState.lastCardDeclared = false;

            // Deal 7 cards to each player
            for (let i = 0; i < 7; i++) {
                gameState.playerHand.push(gameState.deck.pop());
                gameState.aiHand.push(gameState.deck.pop());
            }

            // Start discard pile
            gameState.discardPile.push(gameState.deck.pop());
        }

        function updateDisplay() {
            // Update card counts
            document.getElementById('playerCardCount').textContent = gameState.playerHand.length;
            document.getElementById('aiCardCount').textContent = gameState.aiHand.length;
            document.getElementById('deckCount').textContent = gameState.deck.length;

            // Update AI cards display
            const aiCardsContainer = document.getElementById('aiCards');
            aiCardsContainer.innerHTML = '';
            for (let i = 0; i < gameState.aiHand.length; i++) {
                const cardBack = document.createElement('div');
                cardBack.className = 'card-back';
                cardBack.textContent = '🂠';
                aiCardsContainer.appendChild(cardBack);
            }

            // Update discard pile
            const topCard = gameState.discardPile[gameState.discardPile.length - 1];
            const discardElement = document.getElementById('discardCard');
            discardElement.textContent = `${topCard.rank}${topCard.suit}`;
            discardElement.className = `discard-card ${suitColors[topCard.suit]}`;

            // Update player hand
            updatePlayerHand();

            // Update controls
            updateControls();

            // Check for Last Card button
            updateLastCardButton();
        }

        function updatePlayerHand() {
            const handContainer = document.getElementById('playerHand');
            handContainer.innerHTML = '';

            gameState.playerHand.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = `card ${suitColors[card.suit]}`;
                cardElement.textContent = `${card.rank}${card.suit}`;
                cardElement.onclick = () => toggleCardSelection(index);

                // Check if card is selected
                if (gameState.selectedCards.includes(index)) {
                    cardElement.classList.add('selected');
                }

                // Check if card is playable
                if (isCardPlayable(card)) {
                    cardElement.classList.add('playable');
                } else if (gameState.penaltyCount === 0) {
                    cardElement.classList.add('unplayable');
                }

                handContainer.appendChild(cardElement);
            });
        }

        function updateControls() {
            const playBtn = document.getElementById('playBtn');
            const clearBtn = document.getElementById('clearBtn');
            const selectedCount = document.getElementById('selectedCount');
            const pickupBtn = document.getElementById('pickupBtn');
            const pickupCount = document.getElementById('pickupCount');
            const penaltyCounter = document.getElementById('penaltyCounter');

            // Update selected count
            selectedCount.textContent = gameState.selectedCards.length;

            // Show/hide play and clear buttons
            if (gameState.selectedCards.length > 0) {
                playBtn.style.display = 'inline-block';
                clearBtn.style.display = 'inline-block';
            } else {
                playBtn.style.display = 'none';
                clearBtn.style.display = 'none';
            }

            // Handle penalty state
            if (gameState.penaltyCount > 0) {
                pickupBtn.style.display = 'inline-block';
                pickupCount.textContent = gameState.penaltyCount;
                penaltyCounter.style.display = 'block';
                penaltyCounter.textContent = `Pick up ${gameState.penaltyCount} cards`;
            } else {
                pickupBtn.style.display = 'none';
                penaltyCounter.style.display = 'none';
            }
        }

        function updateLastCardButton() {
            const lastCardBtn = document.getElementById('lastCardBtn');
            
            if (gameState.playerHand.length === 1 && !gameState.lastCardDeclared && gameState.penaltyCount === 0) {
                lastCardBtn.style.display = 'inline-block';
            } else {
                lastCardBtn.style.display = 'none';
            }
        }

        function toggleCardSelection(index) {
            if (gameState.penaltyCount > 0 && !canStackPenalty(gameState.playerHand[index])) {
                return; // Can't select cards during penalty unless stacking
            }

            const selectedIndex = gameState.selectedCards.indexOf(index);
            if (selectedIndex > -1) {
                gameState.selectedCards.splice(selectedIndex, 1);
            } else {
                gameState.selectedCards.push(index);
            }
            updateDisplay();
        }

        function isCardPlayable(card) {
            const topCard = gameState.discardPile[gameState.discardPile.length - 1];
            
            // Aces are always playable
            if (card.rank === 'A') return true;
            
            // During penalty, only stacking cards are playable
            if (gameState.penaltyCount > 0) {
                return canStackPenalty(card);
            }
            
            // Normal matching rules
            return card.suit === topCard.suit || card.rank === topCard.rank;
        }

        function canStackPenalty(card) {
            if (gameState.penaltyType === '2' && card.rank === '2') return true;
            if (gameState.penaltyType === 'blackjack' && isBlackJack(card)) return true;
            if (gameState.penaltyType === 'blackjack' && isRedJack(card)) return true;
            return false;
        }

        function isBlackJack(card) {
            return card.rank === 'J' && (card.suit === '♠' || card.suit === '♣');
        }

        function isRedJack(card) {
            return card.rank === 'J' && (card.suit === '♥' || card.suit === '♦');
        }

        function playSelectedCards() {
            if (gameState.selectedCards.length === 0) return;

            const selectedCardObjects = gameState.selectedCards.map(index => gameState.playerHand[index]);
            
            // Validate the play
            if (!isValidPlay(selectedCardObjects)) {
                showMessage("Cannot play selected cards - invalid combination or doesn't match top card");
                return;
            }

            // Check Last Card rule
            if (gameState.playerHand.length - gameState.selectedCards.length === 1 && !gameState.lastCardDeclared) {
                // Apply penalty for not declaring Last Card
                applyLastCardPenalty();
                return;
            }

            // Remove cards from hand (in reverse order to maintain indices)
            gameState.selectedCards.sort((a, b) => b - a);
            const playedCards = [];
            for (let index of gameState.selectedCards) {
                playedCards.unshift(gameState.playerHand.splice(index, 1)[0]);
            }

            // Add to discard pile
            gameState.discardPile.push(...playedCards);

            // Log the play
            const cardNames = playedCards.map(card => `${card.rank}${card.suit}`).join(', ');
            logAction(`Player played: ${cardNames}`, 'player');

            // Handle power card effects
            const lastPlayedCard = playedCards[playedCards.length - 1];
            handlePowerCard(lastPlayedCard, 'player');

            // Clear selection
            gameState.selectedCards = [];

            // Check for win
            if (gameState.playerHand.length === 0) {
                endGame('player');
                return;
            }

            // Switch to AI turn if no skip effect
            if (gameState.currentPlayer === 'player') {
                gameState.currentPlayer = 'ai';
                setTimeout(aiTurn, 1000);
            }

            updateDisplay();
        }

        function isValidPlay(cards) {
            if (cards.length === 0) return false;

            // Check if it's a valid run (same rank)
            if (cards.length > 1) {
                const rank = cards[0].rank;
                if (!cards.every(card => card.rank === rank)) {
                    return false;
                }
            }

            // Check if first card matches top card
            const topCard = gameState.discardPile[gameState.discardPile.length - 1];
            const firstCard = cards[0];

            // During penalty, check stacking rules
            if (gameState.penaltyCount > 0) {
                return canStackPenalty(firstCard);
            }

            // Aces are always playable
            if (firstCard.rank === 'A') return true;

            // Normal matching
            return firstCard.suit === topCard.suit || firstCard.rank === topCard.rank;
        }

        function handlePowerCard(card, player) {
            const opponent = player === 'player' ? 'ai' : 'player';

            switch (card.rank) {
                case '2':
                    if (gameState.penaltyType === '2') {
                        gameState.penaltyCount += 2;
                    } else {
                        gameState.penaltyCount = 2;
                        gameState.penaltyType = '2';
                    }
                    logAction(`${player} played 2 - ${opponent} must pick up ${gameState.penaltyCount} cards!`, 'system');
                    gameState.currentPlayer = opponent;
                    break;

                case 'J':
                    if (isBlackJack(card)) {
                        if (gameState.penaltyType === 'blackjack') {
                            gameState.penaltyCount += 6;
                        } else {
                            gameState.penaltyCount = 6;
                            gameState.penaltyType = 'blackjack';
                        }
                        logAction(`${player} played Black Jack - ${opponent} must pick up ${gameState.penaltyCount} cards!`, 'system');
                        gameState.currentPlayer = opponent;
                    } else if (isRedJack(card)) {
                        if (gameState.penaltyType === 'blackjack') {
                            logAction(`${player} played Red Jack - Black Jack penalty cancelled!`, 'system');
                            gameState.penaltyCount = 0;
                            gameState.penaltyType = '';
                        }
                    }
                    break;

                case '8':
                    logAction(`${player} played 8 - ${opponent}'s turn skipped!`, 'system');
                    // Keep current player for another turn
                    break;

                case 'K':
                    gameState.direction *= -1;
                    logAction(`${player} played King - direction reversed!`, 'system');
                    gameState.currentPlayer = opponent;
                    break;

                case 'A':
                    logAction(`${player} played Ace - suit changed to ${card.suit}!`, 'system');
                    gameState.currentPlayer = opponent;
                    break;

                default:
                    gameState.currentPlayer = opponent;
                    break;
            }
        }

        function aiTurn() {
            if (gameState.currentPlayer !== 'ai') return;

            // Handle penalty
            if (gameState.penaltyCount > 0) {
                // Check if AI can stack
                const stackingCard = gameState.aiHand.find(card => canStackPenalty(card));
                if (stackingCard) {
                    // AI stacks the penalty
                    const index = gameState.aiHand.indexOf(stackingCard);
                    gameState.aiHand.splice(index, 1);
                    gameState.discardPile.push(stackingCard);
                    
                    logAction(`AI played ${stackingCard.rank}${stackingCard.suit} to stack penalty`, 'ai');
                    handlePowerCard(stackingCard, 'ai');
                    updateDisplay();
                    return;
                } else {
                    // AI picks up penalty cards
                    for (let i = 0; i < gameState.penaltyCount; i++) {
                        if (gameState.deck.length === 0) reshuffleDeck();
                        gameState.aiHand.push(gameState.deck.pop());
                    }
                    logAction(`AI picked up ${gameState.penaltyCount} cards!`, 'ai');
                    gameState.penaltyCount = 0;
                    gameState.penaltyType = '';
                    gameState.currentPlayer = 'player';
                    updateDisplay();
                    return;
                }
            }

            // Find playable cards
            const playableCards = gameState.aiHand.filter(card => isCardPlayable(card));
            
            if (playableCards.length > 0) {
                // AI plays a card (simple strategy - play first playable card)
                const cardToPlay = playableCards[0];
                const index = gameState.aiHand.indexOf(cardToPlay);
                gameState.aiHand.splice(index, 1);
                gameState.discardPile.push(cardToPlay);
                
                logAction(`AI played ${cardToPlay.rank}${cardToPlay.suit}`, 'ai');
                
                // Check for AI win
                if (gameState.aiHand.length === 0) {
                    endGame('ai');
                    return;
                }
                
                handlePowerCard(cardToPlay, 'ai');
            } else {
                // AI draws a card
                if (gameState.deck.length === 0) reshuffleDeck();
                gameState.aiHand.push(gameState.deck.pop());
                logAction('AI drew a card', 'ai');
                gameState.currentPlayer = 'player';
            }

            updateDisplay();
        }

        function drawCard() {
            if (gameState.penaltyCount > 0) return;
            
            if (gameState.deck.length === 0) reshuffleDeck();
            gameState.playerHand.push(gameState.deck.pop());
            logAction('Player drew a card', 'player');
            
            gameState.currentPlayer = 'ai';
            setTimeout(aiTurn, 1000);
            updateDisplay();
        }

        function pickupPenalty() {
            for (let i = 0; i < gameState.penaltyCount; i++) {
                if (gameState.deck.length === 0) reshuffleDeck();
                gameState.playerHand.push(gameState.deck.pop());
            }
            
            logAction(`Player picked up ${gameState.penaltyCount} cards`, 'player');
            gameState.penaltyCount = 0;
            gameState.penaltyType = '';
            gameState.currentPlayer = 'ai';
            setTimeout(aiTurn, 1000);
            updateDisplay();
        }

        function declareLastCard() {
            gameState.lastCardDeclared = true;
            logAction('Player declared "Last Card!"', 'player');
            showMessage('Last Card declared! 🗣️');
            updateDisplay();
        }

        function applyLastCardPenalty() {
            gameState.playerHand.push(gameState.deck.pop());
            gameState.playerHand.push(gameState.deck.pop());
            logAction('⚠️ Penalty! Player must declare "Last Card!" - Picked up 2 cards!', 'system');
            showMessage('⚠️ Penalty! You must declare "Last Card!" - Picked up 2 cards!');
            gameState.selectedCards = [];
            updateDisplay();
        }

        function clearSelection() {
            gameState.selectedCards = [];
            updateDisplay();
        }

        function reshuffleDeck() {
            if (gameState.discardPile.length <= 1) return;
            
            const topCard = gameState.discardPile.pop();
            gameState.deck = [...gameState.discardPile];
            gameState.discardPile = [topCard];
            shuffleDeck();
            logAction('Deck reshuffled', 'system');
        }

        function endGame(winner) {
            const gameTime = Date.now() - gameState.gameStartTime;
            const gameTimeSeconds = Math.floor(gameTime / 1000);
            
            logAction(`🎉 ${winner.toUpperCase()} WINS! Game duration: ${gameTimeSeconds}s`, 'system');
            
            // Update statistics
            gameState.sessionStats.games++;
            gameState.totalStats.games++;
            
            if (winner === 'player') {
                gameState.sessionStats.wins++;
                gameState.totalStats.wins++;
                gameState.totalStats.currentStreak++;
                if (gameState.totalStats.currentStreak > gameState.totalStats.bestStreak) {
                    gameState.totalStats.bestStreak = gameState.totalStats.currentStreak;
                }
                if (!gameState.totalStats.fastestWin || gameTimeSeconds < gameState.totalStats.fastestWin) {
                    gameState.totalStats.fastestWin = gameTimeSeconds;
                }
            } else {
                gameState.sessionStats.losses++;
                gameState.totalStats.losses++;
                gameState.totalStats.currentStreak = 0;
            }
            
            if (!gameState.totalStats.longestGame || gameTimeSeconds > gameState.totalStats.longestGame) {
                gameState.totalStats.longestGame = gameTimeSeconds;
            }
            
            saveStats();
            
            // Show win message
            showWinMessage(winner);
        }

        function showWinMessage(winner) {
            const message = document.createElement('div');
            message.className = 'win-message';
            message.innerHTML = `
                <button class="win-close" onclick="this.parentElement.remove()">×</button>
                <div>${winner === 'player' ? '🎉 YOU WIN! 🎉' : '⚡ AI WINS! ⚡'}</div>
                <div style="font-size: 14px; margin-top: 10px;">
                    Final card: ${gameState.discardPile[gameState.discardPile.length - 1].rank}${gameState.discardPile[gameState.discardPile.length - 1].suit}
                </div>
                <button class="control-btn" onclick="startNewGame(); this.parentElement.remove();" style="margin-top: 15px;">
                    Play Again
                </button>
            `;
            document.body.appendChild(message);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (message.parentElement) {
                    message.remove();
                }
            }, 10000);
        }

        function showMessage(text) {
            document.getElementById('gameMessage').textContent = text;
        }

        function logAction(action, type) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = { timestamp, action, type };
            gameState.gameLog.push(entry);
            
            // Update log display if visible
            updateLogDisplay();
        }

        function updateLogDisplay() {
            const logEntries = document.getElementById('logEntries');
            logEntries.innerHTML = '';
            
            gameState.gameLog.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'log-entry';
                entryDiv.innerHTML = `
                    <div class="log-timestamp">[${entry.timestamp}] ${entry.type.toUpperCase()}</div>
                    <div>${entry.action}</div>
                `;
                logEntries.appendChild(entryDiv);
            });
            
            // Scroll to bottom
            logEntries.scrollTop = logEntries.scrollHeight;
        }

        function loadStats() {
            const saved = localStorage.getItem('imperialBlackStats');
            if (saved) {
                const stats = JSON.parse(saved);
                gameState.totalStats = { ...gameState.totalStats, ...stats };
            }
        }

        function saveStats() {
            localStorage.setItem('imperialBlackStats', JSON.stringify(gameState.totalStats));
            updateStatsDisplay();
        }

        function updateStatsDisplay() {
            // Session stats
            document.getElementById('sessionGames').textContent = gameState.sessionStats.games;
            document.getElementById('sessionWins').textContent = gameState.sessionStats.wins;
            document.getElementById('sessionLosses').textContent = gameState.sessionStats.losses;
            document.getElementById('sessionWinRate').textContent = 
                gameState.sessionStats.games > 0 ? 
                Math.round((gameState.sessionStats.wins / gameState.sessionStats.games) * 100) + '%' : '0%';
            
            // Total stats
            document.getElementById('totalGames').textContent = gameState.totalStats.games;
            document.getElementById('totalWins').textContent = gameState.totalStats.wins;
            document.getElementById('totalLosses').textContent = gameState.totalStats.losses;
            document.getElementById('totalWinRate').textContent = 
                gameState.totalStats.games > 0 ? 
                Math.round((gameState.totalStats.wins / gameState.totalStats.games) * 100) + '%' : '0%';
            
            document.getElementById('fastestWin').textContent = 
                gameState.totalStats.fastestWin ? gameState.totalStats.fastestWin + 's' : '--';
            document.getElementById('longestGame').textContent = 
                gameState.totalStats.longestGame ? gameState.totalStats.longestGame + 's' : '--';
            document.getElementById('bestStreak').textContent = gameState.totalStats.bestStreak;
        }

        function resetStats() {
            if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
                gameState.sessionStats = { games: 0, wins: 0, losses: 0 };
                gameState.totalStats = { games: 0, wins: 0, losses: 0, fastestWin: null, longestGame: null, bestStreak: 0, currentStreak: 0 };
                localStorage.removeItem('imperialBlackStats');
                updateStatsDisplay();
            }
        }

        // Screen management
        function showScreen(screenName) {
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Show selected screen
            document.getElementById(screenName).classList.add('active');
            
            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Update displays based on screen
            if (screenName === 'log') {
                updateLogDisplay();
            } else if (screenName === 'scores') {
                updateStatsDisplay();
            }
        }

        function startNewGame() {
            showScreen('game');
            initializeGame();
        }

        function showRules() {
            alert(`Imperial Black Rules:

🎯 OBJECTIVE: Be the first to play all your cards

🃏 POWER CARDS:
• 2: Next player picks up 2 cards (stackable up to 8)
• Black Jack (♠/♣): Next player picks up 6 cards (stackable up to 24)
• Red Jack (♥/♦): Cancels Black Jack penalty
• King: Reverses direction of play
• 8: Skips next player's turn
• Ace: Changes suit to suit of Ace played

🗣️ LAST CARD RULE:
Must declare "Last Card!" when down to one card or pick up 2 penalty cards

🎮 HOW TO PLAY:
• Match suit or rank of top card
• Power cards can be played in runs
• Click cards to select, then click "Play Selected"
• Use "Last Card!" button when you have 1 card`);
        }

        // Initialize on page load
        window.onload = function() {
            loadStats();
            updateStatsDisplay();
        };
    </script>
</body>
</html>
